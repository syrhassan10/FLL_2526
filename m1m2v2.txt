from hub import port, motion_sensor, light_matrix
import runloop
import motor
import motor_pair
import math

# =========================
# Drivebase Setup & Globals
# =========================
PAIR = motor_pair.PAIR_1
motor_pair.pair(PAIR, port.C, port.D)# Left=C, Right=D

# Polarity (if robot steers the wrong way, flip to -1)
STEER_SIGN = 1

# Absolute heading bookkeeping (0° after init)
current_heading = 0.0

# Wheel & distance calibration
WHEEL_DIAM_CM = 5.6
CIRCUM_CM    = math.pi * WHEEL_DIAM_CM
DIST_GAIN    = 1.00# tweak to fix over/under-travel (e.g., 0.985 or 1.015)

def cm_to_deg(cm):
    """Convert chassis cm → wheel degrees with a simple scalar gain."""
    return (cm * DIST_GAIN / CIRCUM_CM) * 360.0

# -------- Speed/Accel Profiles (Balanced defaults for FLL) --------
# Straight (deg/s and deg/s^2 of wheel rotation)
MAX_SPEED_STRAIGHT = 720    # ~ moderate-fast but controllable
A_STRAIGHT        = 2200
D_STRAIGHT        = 2600
MIN_STRAIGHT    = 140

# Turn in place (deg/s and deg/s^2 of motor command)
MIN_TURN_SPEED    = 120
MAX_TURN_SPEED    = 540
A_TURN            = 2200
D_TURN            = 2800

# Heading hold (straight driving): P + small D, with steering cap and yaw smoothing
K_HEADING_P        = 0.85
K_HEADING_D        = 0.10    # gentle damping from error slope (computed numerically)
STEER_CAP        = 26
YAW_SMOOTH_ALPHA= 0.25    # 0..1 (bigger = more smoothing)

# Turn tolerance (absolute turns)
TURN_TOL_DEG    = 1.5
TURN_IN_TOL_NEED= 3        # consecutive loops in tolerance before declaring done

# Loop timing
LOOP_MS = 10
DT    = LOOP_MS / 1000.0

# -----------------
# Friendly Setters
# -----------------
def set_drive_ports(left_port, right_port):
    global PAIR
    motor_pair.pair(PAIR, left_port, right_port)

def set_steer_sign(sign):
    global STEER_SIGN
    STEER_SIGN = 1 if sign >= 0 else -1

def set_wheel_diameter_cm(d_cm):
    global WHEEL_DIAM_CM, CIRCUM_CM
    WHEEL_DIAM_CM = d_cm
    CIRCUM_CM    = math.pi * WHEEL_DIAM_CM

def set_distance_gain(g):
    """>1 travels farther; <1 travels shorter for same cm command."""
    global DIST_GAIN
    DIST_GAIN = g

def set_straight_profile(max_speed=None, accel=None, decel=None, min_speed=None):
    global MAX_SPEED_STRAIGHT, A_STRAIGHT, D_STRAIGHT, MIN_STRAIGHT
    if max_speed is not None: MAX_SPEED_STRAIGHT = max_speed
    if accel    is not None: A_STRAIGHT        = accel
    if decel    is not None: D_STRAIGHT        = decel
    if min_speed is not None: MIN_STRAIGHT    = min_speed

def set_turn_profile(min_speed=None, max_speed=None, accel=None, decel=None):
    global MIN_TURN_SPEED, MAX_TURN_SPEED, A_TURN, D_TURN
    if min_speed is not None: MIN_TURN_SPEED = min_speed
    if max_speed is not None: MAX_TURN_SPEED = max_speed
    if accel    is not None: A_TURN        = accel
    if decel    is not None: D_TURN        = decel

def set_heading_hold(kp=None, kd=None, cap=None, yaw_alpha=None):
    global K_HEADING_P, K_HEADING_D, STEER_CAP, YAW_SMOOTH_ALPHA
    if kp        is not None: K_HEADING_P    = kp
    if kd        is not None: K_HEADING_D    = kd
    if cap    is not None: STEER_CAP        = int(cap)
    if yaw_alpha is not None: YAW_SMOOTH_ALPHA = max(0.0, min(1.0, yaw_alpha))

def apply_preset(name="balanced"):
    """Quick presets for different tables/robots."""
    n = name.lower()
    if n == "precise":
        set_straight_profile(max_speed=600, accel=2000, decel=2600, min_speed=130)
        set_turn_profile(min_speed=110, max_speed=460, accel=2000, decel=2800)
        set_heading_hold(kp=0.95, kd=0.12, cap=22, yaw_alpha=0.30)
    elif n == "fast":
        set_straight_profile(max_speed=840, accel=2600, decel=3000, min_speed=150)
        set_turn_profile(min_speed=130, max_speed=600, accel=2600, decel=3200)
        set_heading_hold(kp=0.80, kd=0.08, cap=28, yaw_alpha=0.20)
    else:# balanced (default)
        set_straight_profile(max_speed=720, accel=2200, decel=2600, min_speed=140)
        set_turn_profile(min_speed=120, max_speed=540, accel=2200, decel=2800)
        set_heading_hold(kp=0.85, kd=0.10, cap=26, yaw_alpha=0.25)

# ======================
# Low-level Sensor Utils
# ======================
def wrap180(a): return (a + 180) % 360 - 180

def _raw_yaw_deg():
    """Prefer true yaw if available; otherwise fall back (your earlier method)."""
    try:
        # Many firmware versions provide a direct yaw angle:
        return motion_sensor.yaw_angle()
    except:
        # Fallback you used earlier (kept for compatibility with your hub build)
        return motion_sensor.tilt_angles()[0] / 10.0

# Exponential smoothing on a circle (keeps behavior simple but stable)
_yaw_filt = None
def yaw_deg():
    global _yaw_filt
    y = _raw_yaw_deg()
    if _yaw_filt is None:
        _yaw_filt = y
        return y
    delta = ((y - _yaw_filt + 540) % 360) - 180# smallest signed delta
    _yaw_filt = wrap180(_yaw_filt + YAW_SMOOTH_ALPHA * delta)
    return _yaw_filt

def ang_diff(target, current):
    """Signed shortest path target - current, in degrees (-180..180)."""
    return (target - current + 540) % 360 - 180

# Encoder helpers (flip C so forward counts positive)
def left_deg():return -motor.relative_position(port.C)
def right_deg(): return motor.relative_position(port.D)
def avg_deg():return (left_deg() + right_deg()) / 2

# ==========================
# TURN: Absolute (trapezoid)
# ==========================
async def turn_to_heading(target_deg):
    """Rotate in place to absolute heading with a trapezoidal speed profile."""
    v = 0.0                # commanded turn speed magnitude (deg/s)
    in_tol = 0

    while True:
        err = ang_diff(target_deg, yaw_deg())# [-180, 180]
        mag = abs(err)

        if mag <= TURN_TOL_DEG:
            in_tol += 1
            if in_tol >= TURN_IN_TOL_NEED:
                break
        else:
            in_tol = 0

        # P-like desired speed, then clamp by braking distance
        v_target = min(MAX_TURN_SPEED, max(MIN_TURN_SPEED, mag * 6.0))# K≈6
        v_brake= math.sqrt(max(0.0, 2.0 * D_TURN * mag))
        v_target = min(v_target, v_brake)

        # Slew toward target speed
        if v < v_target: v = min(v + A_TURN * DT, v_target)
        else:            v = max(v - D_TURN * DT, v_target)

        # +err → need RIGHT turn (right motor forward, left reverse)
        steer = STEER_SIGN * (-100 if err > 0 else +100)
        motor_pair.move(PAIR, steer, velocity=int(v))
        await runloop.sleep_ms(LOOP_MS)

    motor_pair.stop(PAIR)

    # Tiny settle/nudge if needed (quick, low-speed clean-up)
    await runloop.sleep_ms(20)
    err = ang_diff(target_deg, yaw_deg())
    if abs(err) > 0.8:
        # brief gentle nudge
        steer = STEER_SIGN * (-100 if err > 0 else +100)
        motor_pair.move(PAIR, steer, velocity=140)
        await runloop.sleep_ms(int(120 + 4 * abs(err)))# ~proportional
        motor_pair.stop(PAIR)

# ---------------------------
# Turns API (relative/absolute)
# ---------------------------
async def turn_left(angle):
    global current_heading
    target = wrap180(current_heading + angle)
    await turn_to_heading(target)
    current_heading = target

async def turn_right(angle):
    global current_heading
    target = wrap180(current_heading - angle)
    await turn_to_heading(target)
    current_heading = target

async def turn_to(target_abs_deg):
    global current_heading
    target = wrap180(target_abs_deg)
    await turn_to_heading(target)
    current_heading = target

# =====================================
# DRIVE: Distance with heading holding
# =====================================
async def drive_cm_hold(distance_cm, speed=None):
    """
    Drive a distance while holding 'current_heading' using PD steering and
    a trapezoidal speed profile. Positive = forward, negative = backward.
    """
    target_degs = abs(cm_to_deg(distance_cm))
    direction= 1 if distance_cm >= 0 else -1

    # External speed cap if given
    v_cap = min(abs(speed) if speed is not None else MAX_SPEED_STRAIGHT, MAX_SPEED_STRAIGHT)

    # zero encoders for distance tracking
    motor.reset_relative_position(port.C, 0)
    motor.reset_relative_position(port.D, 0)

    v = 0.0
    prev_err = ang_diff(current_heading, yaw_deg())

    while True:
        progressed = abs(avg_deg())
        remaining= max(target_degs - progressed, 0.0)
        if remaining <= 1.0:
            break

        # PD steering about absolute heading
        herr = ang_diff(current_heading, yaw_deg())
        derr = (herr - prev_err) / DT
        prev_err = herr

        steer_raw = K_HEADING_P * herr + K_HEADING_D * derr
        steer_cmd = int(max(-STEER_CAP, min(STEER_CAP, steer_raw)))

        # Reverse-aware correction (flip sign when backing up)
        steer_cmd = STEER_SIGN * (-steer_cmd) * direction

        # Trapezoid target speed with braking bound
        v_target = v_cap
        v_brake= math.sqrt(max(0.0, 2.0 * D_STRAIGHT * remaining))
        v_target = min(v_target, v_brake)
        v_target = max(min(v_target, v_cap), MIN_STRAIGHT)# floor

        # Slew toward target speed
        if v < v_target: v = min(v + A_STRAIGHT * DT, v_target)
        else:            v = max(v - D_STRAIGHT * DT, v_target)

        motor_pair.move(PAIR, steer_cmd, velocity=int(v) * direction)
        await runloop.sleep_ms(LOOP_MS)

    motor_pair.stop(PAIR)

# ===========================
# Match-start Calibration
# ===========================
def calibrate_at_start():
    """Standardize start: zero yaw, encoders, and filter."""
    motion_sensor.reset_yaw(0)
    motor.reset_relative_position(port.C, 0)
    motor.reset_relative_position(port.D, 0)
    global current_heading, _yaw_filt
    current_heading = 0.0
    _yaw_filt = None# next yaw() call re-seeds the filter

# ==========
# MAIN PLAN
# ==========
async def main():
    # Choose a preset (balanced/precise/fast), then tweak via setters if you like
    apply_preset("balanced")
    # Example: small table runs benefit from a tad more damping & cap
    # set_heading_hold(kp=0.90, kd=0.12, cap=24)

    calibrate_at_start()


    await drive_cm_hold(68)
    await runloop.sleep_ms(100)
    # set_turn_profile(min_speed=None, max_speed=120, accel=None, decel=None)
    await turn_left(30)

    await drive_cm_hold(9)
    await motor.run_for_degrees(port.E, -95, 720)
    motor_pair.move_for_degrees(PAIR, -1700, -5, velocity=1000, acceleration=10000)
    await runloop.sleep_ms(180)
    motor.run_for_degrees(port.A, -69, 1150)

    return

runloop.run(main())
